

    // initialize stack pointer here
    // we have 16-bit, 16K computer, => 16384 addresses in total
    // start in the end of Ram for stack, @16383
    @16383
    D=A
    @SPC
    M=D



// Let's try using stack instead
// and see how functions could be called recursively

    // skip if function is not called (just the declaration here)
    @MFEnd  // GOTO
    0;JMP  // GOTO
(MF) //MF stands for multiplication function
    // we have MF0, MF1, and MF2 as global variables 
    // reserved for this function
    // Multiplies MF0 and MF1 and stores the result in MF2
    // caller functions will have to set MF0 and MF1

    // initialize MF1 and MF0 from stack
	@SPC  //POP 
	M=M+1  //POP 
	A=M  //POP 
	D=M  //POP 
    @MF1
    M=D
	@SPC  //POP 
	M=M+1  //POP 
	A=M  //POP 
	D=M  //POP 
    @MF0
    M=D

    //initialize MF2=0
    @0  // ASSIGN
    D=A  // ASSIGN
    @MF2  // ASSIGN
    M=D  // ASSIGN

    @MF0
    D=M
    @MF1
    D=D-M //MF0-MF1
    @MF1LessThanMF0
    D;JLT  //MF0 <= MF1
    
    // q = MF1
    @MF1  // ASSIGN
    D=M  // ASSIGN
    @q  // ASSIGN
    M=D  // ASSIGN
    @MF0  // ASSIGN
    D=M  // ASSIGN
    @p  // ASSIGN
    M=D  // ASSIGN
    @ENDMF1LessThanMF0  // GOTO
    0;JMP  // GOTO

(MF1LessThanMF0) //R[1] < R[0]
    @MF1  // ASSIGN
    D=M  // ASSIGN
    @p  // ASSIGN
    M=D  // ASSIGN
    @MF0  // ASSIGN
    D=M  // ASSIGN
    @q  // ASSIGN
    M=D  // ASSIGN

(ENDMF1LessThanMF0)
    //r=1
    @1  // ASSIGN
    D=A  // ASSIGN
    @r  // ASSIGN
    M=D  // ASSIGN

(LOOP)
    @q
    D=M
    @ENDLoop
    D;JEQ // end when q=0

    @q
    D=M
    @r
    D=D&M
    @POSTADD
    D;JEQ //do not add if bit doesn't match

    @p
    D=M
    @MF2
    M=D+M // adding p to value at MF2

(POSTADD) //update p, q, r for next iteration
    @p
    D=M
    M=D+M //p = p+p
    
    @r
    D=!M
    @q
    M=D&M  //q=q&(!r)

    @r
    D=M
    M=D+M //r=r+r

    @LOOP  // GOTO
    0;JMP  // GOTO

(ENDLoop)

    // Return statement 
    // Jump to where function was called from using stack pointer
    // This is assuming that there is no overflow in SPC
    // essentially return to last address stored in stack
	@SPC  //POP 
	M=M+1  //POP 
	A=M  //POP 
	D=M  //POP 
    A=D
    0;JMP  // jump to current address

    // this is where control should come to, if function is not called
(MFEnd) 

    // initialize sum to 0
    @0  // ASSIGN
    D=A  // ASSIGN
    @sum  // ASSIGN
    M=D  // ASSIGN

    // call MF with return address, M0 and M1
        @c1EndAddress  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
        @5  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
        @7  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
    @MF  // GOTO
    0;JMP  // GOTO
(c1EndAddress)
    //store result of calculation
    @MF2  // ASSIGN
    D=M  // ASSIGN
    @R0  // ASSIGN
    M=D  // ASSIGN


    // call MF with return address, M0 and M1
        @c2EndAddress  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
        @11  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
        @32  //PUSH
        D=A  //PUSH
	@SPC  //PUSH 
	A=M  //PUSH 
	M=D  //PUSH 
	@SPC  //PUSH 
	M=M-1  //PUSH 
    @MF  // GOTO
    0;JMP  // GOTO
(c2EndAddress)
    //store result of calculation
    @MF2  // ASSIGN
    D=M  // ASSIGN
    @R1  // ASSIGN
    M=D  // ASSIGN

(END)
    @END  // GOTO
    0;JMP  // GOTO





