function Memory.init 0
	push constant 0
	pop static 0  // MEM
	push constant 2048
	pop static 1  // freeList
	push static 1  // freeList
	push constant 0
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push constant 0  // null
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push static 1  // freeList
	push constant 1
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push constant 14334
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push constant 0
	return
function Memory.peek 0
	push static 0  // MEM
	push argument 0  // address
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	return
function Memory.poke 0
	push static 0  // MEM
	push argument 0  // address
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push argument 1  // value
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push constant 0
	return
function Memory.alloc 3
	push argument 0  // size
	push constant 1
	lt
	not
	if-goto ELSE0
	push constant 5
	call Sys.error 1
	return
	goto ELSE_END0
label ELSE0
label ELSE_END0
	push constant 0  // null
	pop local 0  // prevNode
	push static 1  // freeList
	pop local 1  // currNode
label LOOP1
	push local 1  // currNode
	push constant 0  // null
	eq
	not
	not
	if-goto ENDLOOP1
	push local 1  // currNode
	push constant 1
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	push argument 0  // size
	push constant 1
	add
	gt
	not
	if-goto ELSE2
	push local 1  // currNode
	push argument 0  // size
	push constant 2
	add
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push local 1  // currNode
	push constant 0
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 1  // currNode
	push argument 0  // size
	push constant 3
	add
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push local 1  // currNode
	push constant 1
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	push argument 0  // size
	push constant 2
	add
	sub
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 0  // prevNode
	push constant 0  // null
	eq
	not
	if-goto ELSE3
	push local 1  // currNode
	push argument 0  // size
	push constant 2
	add
	add
	pop static 1  // freeList
	goto ELSE_END3
label ELSE3
	push local 0  // prevNode
	push constant 0
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push local 1  // currNode
	push argument 0  // size
	push constant 2
	add
	add
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
label ELSE_END3
	push local 1  // currNode
	push constant 2
	add
	pop local 2  // ramBlock
	push local 2  // ramBlock
	push constant 1
	neg
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push argument 0  // size
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 2  // ramBlock
	push constant 2
	neg
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push constant 0  // null
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 2  // ramBlock
	return
	goto ELSE_END2
label ELSE2
label ELSE_END2
	push local 1  // currNode
	push constant 1
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	push argument 0  // size
	push constant 1
	sub
	gt
	not
	if-goto ELSE4
	push local 0  // prevNode
	push constant 0  // null
	eq
	not
	if-goto ELSE5
	push local 1  // currNode
	push constant 0
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	pop static 1  // freeList
	goto ELSE_END5
label ELSE5
	push local 0  // prevNode
	push constant 0
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push local 1  // currNode
	push constant 0
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
label ELSE_END5
	push local 1  // currNode
	push constant 2
	add
	pop local 2  // ramBlock
	push local 2  // ramBlock
	push constant 1
	neg
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push argument 0  // size
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 2  // ramBlock
	push constant 2
	neg
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push constant 0  // null
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push local 2  // ramBlock
	return
	goto ELSE_END4
label ELSE4
label ELSE_END4
	push local 1  // currNode
	pop local 0  // prevNode
	push local 1  // currNode
	push constant 0
	add  // termArrEnd
	pop pointer 1  // that = &arr + arrIdx
	push that 0  // push arr[arrIdx] on stack
	pop local 1  // currNode
	goto LOOP1
label ENDLOOP1
	push constant 6
	call Sys.error 1
	return
function Memory.deAlloc 0
	push argument 0  // o
	push constant 2
	neg
	add  // letArrayEnd
	pop temp 0  // arr = arr + i
	push static 1  // freeList
	push temp 0
	pop pointer 1  // that = &arr + i
	pop that 0  // *(arr+i) = exp_value
	push argument 0  // o
	push constant 2
	sub
	pop static 1  // freeList
	push constant 0
	return
